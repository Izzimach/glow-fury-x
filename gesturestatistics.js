pc.script.create('gesturestatistics', function (context) {
    // Creates a new Gesturestatistics instance
    var Gesturestatistics = function (entity) {
        this.entity = entity;
    };
    
    // private function to compute cross-produce
    function crossvec2(v1, v2) {
        var v1x = v1[0];
        var v1y = v1[1];
        var v2x = v2[0];
        var v2y = v2[1];
        var cross = (v1x * v2y) - (v1y * v2x);
        var a = Math.sqrt(v1x * v1x + v1y * v1y);
        var b = Math.sqrt(v2x * v2x + v2y * v2y);
        
        return cross / (a*b);
    }

    Gesturestatistics.prototype = {
        // Called once after all resources are loaded and before the first update
        initialize: function () {
            this.entity.script.send('gestureprocessor','linkGestureStatisticsComponent',this);
        },

        // Called every frame, dt is time in seconds since last update
        update: function (dt) {
        },
        
        analyzeGesture: function(gesturepath) {
            var results = {};
            if (gesturepath.length < 2)
            {
                return results;
            }
            
            //
            // compute mean and total gesture length
            //
            
            var sumx=0, sumy=0;
            var sumdistance=0;
            _.each(gesturepath, function (element,index,list) {
                
                sumx += element[0];
                sumy += element[1];
                if (index < list.length-1)
                {
                    var nextelement = list[index+1];
                    var dx = element[0] - nextelement[0];
                    var dy = element[1] - nextelement[1];
                    var deltad = Math.sqrt(dx*dx+dy*dy);
                    sumdistance += deltad;
                }
            });
            
            var Xmean = sumx / gesturepath.length;
            var Ymean = sumy / gesturepath.length;
            results.gesturelength = sumdistance;
            
            // distance from start point to end point
            var firstelement = _.first(gesturepath);
            var lastelement = _.last(gesturepath);
            var totaldx = firstelement[0] - lastelement[0];
            var totaldy = firstelement[1] - lastelement[1];
            results.endpointdistance = Math.sqrt(totaldx*totaldx + totaldy*totaldy);
            
            
            // compute 2x2 covariance matrix and then the principal components
            // note that cov12 and cov21 are indentical, so we don't compute cov21
            var cov11 = 0, cov12 = 0, cov22 = 0;
            
            for (var computeindex = 0; computeindex < gesturepath.length; computeindex++)
            {
                    var computePoint = gesturepath[computeindex];
                    var dx = Xmean - computePoint[0];
                    var dy = Ymean - computePoint[1];
                    
                    cov11 += dx * dx;
                    cov12 += dy * dx;
                    // cov21 = cov12
                    cov22 += dy * dy;
            }
            var covnormalize = gesturepath.length - 1;
            results.cov11 = cov11 / covnormalize;
            results.cov21 = cov12 / covnormalize;
            results.cov22 = cov22 / covnormalize;
            
            // compute eigenvalues of the 2x2 covariance matrix
            var T = cov11 + cov22; // trace
            var D = cov11 * cov22 - cov12 * cov12; // determinant
            
            var k1 = T / 2;
            var k2 = Math.sqrt((T * T) / 4 - D);
            
            var L1 = k1 + k2;
            var L2 = k1 - k2;
            results.eig1 = L1;
            results.eig2 = L2;
            
            
            
            // now add up the total angle generated by points going around the center
            var totalangle = 0;
            var dP1 = pc.math.vec2.create();
            var dP2 = pc.math.vec2.create();
            for (var i = 1; i < gesturepath.length; i++)
            {
                    var p1 = gesturepath[i - 1];
                    var p2 = gesturepath[i];
                    pc.math.vec2.set(dP1,p1[0] - Xmean, p1[1] - Ymean);
                    pc.math.vec2.set(dP2,p2[0] - Xmean, p2[1] - Ymean);
                    var segmentcross = crossvec2(dP1, dP2);
                    var segmentangle = Math.asin(segmentcross);
                    totalangle += segmentangle;
            }
            //results.totalcrankangle = -totalangle; // clockwise is positive
            results.crankangle = totalangle;
            
            pc.log.write("covariance matrix=" + results.cov11 + "," + results.cov21 + "," + results.cov22);
            pc.log.write("endpointdistance=" + results.endpointdistance);
            pc.log.write("total length=" + results.gesturelength);
            pc.log.write("eigenvalues=" + results.eig1 + "," + results.eig2);
            pc.log.write("crank angle=" +results.crankangle);
            
            return results;
        },
        
        classifyGesture: function(gesturepath, gesturestats) {
            var stats = gesturestats || this.analyzeGesture(gesturepath);
            
            // very short gestures are always considered taps to preserve my sanity
            if (stats.totallength < 20 || gesturepath.length < 10)
            {
                return this.TAP;
            }
            
            // check eigenvalues for a rough idea of the gesture type
            // avoid bad results if eig2 is near zero
            var eigratio = (stats.eig2 > 1e-4) ? (stats.eig1 / stats.eig2) : 1e6;
            var endratio = stats.endpointdistance / stats.gesturelength;
            if (eigratio > 100)
            {
                // along a thin line, probably a straightline or a precise zigzag
                if (endratio > 0.7)
                {
                    return this.STRAIGHTLINE;
                }
                else if (endratio > 0.1)
                {
                    return this.ZIGZAG;
                }
                else // ?? half a zigzag, maybe?
                {
                    return this.UNKNOWNGESTURE;
                }
            } else if (eigratio > 10) {
                // either a squiggly or a zigzag. check the endratio
                if (endratio > 0.7)
                {
                    return this.SQUIGGLYLINE;
                }
                else if (endratio > 0.1)
                {
                    return this.ZIGZAG;
                }
                else
                {
                    return this.UNKNOWNGESTURE;
                }
            } else {
                // either a round zigzag or a flat circle. we can
                // distinguish them by checking the crank angle. circle should
                // have a crank angle near +-2pi, while zigzags should have one
                // less than +-pi
                if (stats.crankangle < -6.0)
                {
                    return this.COUNTERCLOCKWISECIRCLE;
                }
                else if (stats.crankangle > 6.0)
                {
                    return this.CLOCKWISECIRCLE;
                }
                else if (Math.abs(stats.crankangle) < 3.0)
                {
                    return this.ZIGZAG;
                }
                else
                {
                    return this.UNKNOWN;
                }
            }
            return this.UNKNOWNGESTURE;
        },
        
        // some gestures
        STRAIGHTLINE:"straightline",
        SQUIGGLYLINE:"squigglyline",
        ZIGZAG:"zigzag",
        CLOCKWISECIRCLE:"cwcircle",
        COUNTERCLOCKWISECIRCLE:"ccwcircle",
        TAP:"tap",
        UKNOWN:"unknown"
    };

    return Gesturestatistics;
});